package example.transactions.examples;

// Spring Beans
// ├── Что такое Bean
// │ ├── Java-объект, управляемый Spring контейнером
// │ ├── Создается, конфигурируется, управляется Spring'ом
// │ └── Может быть сервис, репозиторий, компонент и т.д.
// │
// ├── Как Spring узнаёт, что это Bean?
// │ ├── Через аннотации:
// │ │ ├── @Component — универсальная аннотация
// │ │ ├── @Service — для сервисов (удобочитаемость)
// │ │ ├── @Repository — для классов, работающих с БД
// │ │ └── @Controller / @RestController — для web
// │ └── Или через конфигурационный класс:
// │ └── @Configuration + @Bean методы (ручное создание)
// │
// ├── Где Spring ищет Beans?
// │ ├── Через component scanning:
// │ │ └── По умолчанию ищет в том пакете, где находится @SpringBootApplication
// │ └── Можно указать вручную: @ComponentScan("com.example.my")
// │
// ├── Контейнер, который управляет Bean'ами
// │ ├── ApplicationContext — главный интерфейс
// │ ├── Создает все Bean'ы
// │ ├── Связывает зависимости (@Autowired)
// │ └── Управляет жизненным циклом (init, destroy и т.д.)
// │
// ├── Жизненный цикл Bean'а
// │ ├── 1. Создание (через конструктор или фабрику)
// │ ├── 2. Внедрение зависимостей (@Autowired / @Value)
// │ ├── 3. Настройка (например, @PostConstruct)
// │ ├── 4. Использование
// │ └── 5. Завершение (например, @PreDestroy)
// │
// ├── Внедрение зависимостей (DI)
// │ ├── @Autowired — внедряет Bean по типу (default)
// │ ├── @Qualifier — уточняет, какой Bean, если несколько
// │ ├── @Value — внедряет значения из application.yml
// │ └── Через конструктор, поле или setter
// │
// ├── Скоупы (Scopes)
// │ ├── Singleton (по умолчанию) — один Bean на всё приложение
// │ ├── Prototype — каждый раз новый Bean
// │ ├── Request — новый Bean на каждый HTTP-запрос (для web)
// │ ├── Session — один Bean на HTTP-сессию
// │ └── Application — один Bean на ServletContext
// │
// ├── Как работает Spring с Bean'ами под капотом?
// │ ├── На старте приложения:
// │ │ ├── Spring сканирует классы (component scan)
// │ │ ├── Регистрирует Bean'ы в ApplicationContext
// │ │ ├── Создаёт объекты (если singleton)
// │ │ └── Внедряет зависимости
// │ ├── В момент использования:
// │ │ ├── Возвращает Bean из ApplicationContext
// │ │ └── Вызывает методы (возможно, через прокси)
// │ └── При завершении:
// │ └── Вызывает методы @PreDestroy, если есть
// │
// ├── Прокси (важно!)
// │ ├── Если над Bean'ом есть аннотация типа @Transactional, @Async, @Cacheable
// │ ├── То Spring оборачивает Bean в прокси (JDK или CGLIB)
// │ ├── Это позволяет "вклиниваться" в метод и делать магию:
// │ │ ├── Начать транзакцию
// │ │ ├── Запустить в новом потоке
// │ │ └── Вернуть кэшированный результат
// │ └── Важно: работает только при вызове метода извне, не из себя!
// │
// ├── Где часто ошибаются
// │ ├── @Autowired не сработал → нету Bean или не тот скоуп
// │ ├── Прокси не сработал → метод вызван внутри самого Bean
// │ ├── Два Bean одного типа → нужен @Qualifier
// │ ├── Неправильный скоуп → Bean пересоздается или шарится неправильно
// │ └── Класс не в пакете сканирования → не найдёт Bean
// │
// └── Лучшие практики
// ├── Использовать @Component только если это не сервис/репозиторий
// ├── Всегда отдавать предпочтение constructor injection
// ├── Избегать field injection (труднее тестировать)
// ├── Всегда понимать скоуп!
// └── Избегать сложной логики в @PostConstruct
public class SpringBeanExample {

}
