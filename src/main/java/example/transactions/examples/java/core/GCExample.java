package example.transactions.examples.java.core;

// Garbage Collector (GC) — полный, подробный разбор
// │
// |
// |
// |
// |
// |
// ├── Что это такое:
// │ ├── Механизм JVM для автоматического управления памятью: обнаруживает объекты, на которые нет
// ссылок, и освобождает занятую ими память.
// │ ├── Работает над Heap (кучей) — областью памяти, где создаются объекты во время выполнения
// приложения.
// │ ├── Основная цель: предотвратить переполнение кучи (OutOfMemoryError) и минимизировать влияние
// очистки на производительность и задержки приложения.
// │ └── Баланс интересов: максимальная пропускная способность vs минимальные задержки vs
// предсказуемость пауз.
// │
// │
// |
// |
// |
// |
// |
// ├── Почему это важно:
// │ ├── Неправильный GC/настройки → частые длинные паузы, OOME, падения throughput.
// │ ├── Правильный выбор коллектора и тюнинг — критичны для серверных приложений (latency-sensitive
// и throughput-oriented).
// │ └── Понимание внутренних механизмов помогает диагностировать утечки, промоции объектов,
// фрагментацию, «promotion failure» и т.д.
// │
// │
// |
// |
// |
// |
// |
// ├── Ключевые понятия и термины:
// │ ├── GC roots — стартовые точки (локальные переменные стеков, статические поля, JNI-локи,
// активные потоки и т.д.).
// │ ├── Reachability (достижимость):
// │ │ ├── Strong (сильные) — обычные ссылки
// │ │ ├── Soft — собираются при недостатке памяти (кеш-подобно)
// │ │ ├── Weak — быстро собираются, используются в WeakHashMap
// │ │ └── Phantom — для пост-очистки и взаимодействия с ReferenceQueue
// │ ├── Finalization / Cleaner — finalize() устаревший; Cleaner (java.lang.ref.Cleaner) —
// предпочтительная замена.
// │ └── Stop-the-world (STW) — паузы, когда все mutator-потоки приостанавливаются для выполнения
// части GC.
// │
// |
// |
// |
// |
// |
// |
// ├── cтруктура памяти Heap (в терминах HotSpot/современных collectors):
// │ ├── Young Generation (Young):
// │ │ ├── Eden — новые объекты попадают сюда
// │ │ └── Survivor0 / Survivor1 — «выжившие» после Minor GC перемещаются между ними
// │ ├── Old (Tenured) Generation — долгоживущие объекты; сюда продвигаются (promote) выжившие
// объекты после ряда сборок
// │ ├── Metaspace — метаданные классов
// │ ├── Humongous (в G1) — большие объекты, выделенные по-region
// │ └── Thread-Local Allocation Buffers (TLABs) — локальные области выделения памяти для каждого
// потока (ускоряют allocation)
// │ └── TLAB позволяет выделять объект «bump-pointer» (инкремент указателя) без синхронизации.
// ([OpenJDK][1])
// │
// │
// |
// |
// |
// |
// |
// ├── Объект в памяти — layout (важные детали):
// │ ├── Заголовок объекта (object header):
// │ │ ├── Mark word — содержит хэш, информацию о GC, состояние монитора (для synchronized), метки
// для сборщика
// │ │ └── Klass pointer — указатель на мета-информацию класса
// │ ├── Поля объекта (выровненные в памяти по alignment, например 8 байт)
// │ ├── Compressed OOPs — указатели объектов (object references) часто сжимаются (compressed oops)
// для экономии памяти
// │ └── Порождает последствия: allocation size, fragmentation, влияние на TLAB sizing
// │
// │
// |
// |
// |
// |
// |
// ├── Жизненный цикл выделения объекта (быстрый путь и медленный путь)
// │ ├── Быстрый путь (fast path / TLAB):
// │ │ ├── Компилированный код пытается «bump» указатель TLAB (инструкция: увеличить указатель на
// size объекта)
// │ │ ├── Если места достаточно — объект создан без взаимодействия с глобальным heap (без
// блокировок)
// │ │ └── Это делает выделение очень дешёвым (несколько инструкций). ([shipilev.net][2])
// │ ├── Медленный путь (slow path):
// │ │ ├── Если TLAB кончился → поток запрашивает новый TLAB у VM или идёт глобальное выделение
// │ │ ├── Большие объекты (humongous) часто выделяются напрямую в Old/Region, минуя Eden
// │ │ └── Может вызывать синхронизацию и / или запуск Minor GC при нехватке места
// │ └── Писчие барьеры (write barriers) помечают карты (card table) / remembered sets при изменении
// ссылок между регионами/генерациями
// │
// │
// |
// |
// |
// |
// |
// ├── Генерационная идея (Generational GC) — почему она работает:
// │ ├── Наблюдение: большинство объектов короткоживущие (проживут очень мало).
// │ ├── Следовательно — оптимальнее часто очищать «молодое» поколение (где большинство мусора),
// редко — старое.
// │ ├── Minor GC — быстро очищает Young (этап: пометка выживших → копирование / эвакуация в
// Survivor / продвижение).
// │ └── Major / Full GC — полная проверка/очистка Old (дороже).
// │
// │
// |
// |
// |
// |
// |
// ├── Основные фазы GC (в терминах high-level, применимо для многих алгоритмов)
// │ ├── Mark (пометка): определить живые объекты, начиная от GC roots.
// │ ├── Sweep / Clear (сбор): освобождение памяти недостижимых объектов.
// │ ├── Compact / Evacuate: перемещение живых объектов в цельную область для уменьшения
// фрагментации.
// │ ├── Concurrent этапы: часть фаз выполняется параллельно с mutator-потоками (прочие — в STW).
// │ └── Remark / Cleanup: дополнительные шаги для согласования данных, часто требуют короткого STW.
// │
// │
// |
// |
// |
// |
// |
// ├── Стандартные реализации (сравнение — что делает каждая в общих чертах)
// |
// |
// │ ├── Serial GC:
// │ │ ├── Однопоточная, простая, подходит для small heaps / single-threaded apps.
// │ │ └── Все GC-фазы — стоп-мир. (команда: -XX:+UseSerialGC)
// │ │
// │ │
// │ ├── Parallel GC (Throughput):
// │ │ ├── Многопоточный; фокус — общая пропускная способность, не минимальные паузы.
// │ │ └── Хорош для batch/throughput-oriented систем. ( -XX:+UseParallelGC )
// │ │
// │ │
// │ ├── CMS (Concurrent Mark-Sweep) — исторический low-pause collector:
// │ │ ├── Выполняет marking почти конкурентно, но не выполняет компактирование полностью—проблемы
// фрагментации.
// │ │ └── Устарел/частично removed в новых релизах.
// │ │
// │ │
// │ ├── G1 (Garbage-First) — region-based, hybrid, default в многих JDK:
// │ │ ├── Делит heap на регионы фиксированного размера; отслеживает, какие регионы содержат больше
// мусора, и эвакуирует их первыми — «garbage-first».
// │ │ ├── Выполняет concurrent global marking, затем планирует Evacuation (evacuate) регионов;
// поддерживает mixed GC (young + old regions).
// │ │ └── Балансирует паузы, throughput и фрагментацию; хорош в большинстве серверных сценариев.
// │ │
// │ │
// │ ├── ZGC — низколатентный, масштабируемый (Oracle/OpenJDK):
// │ │ ├── Проектирован для очень больших heap (GB → TB) и минимальных пауз (миллисекунды).
// │ │ ├── Почти все тяжелые этапы выполняются конкурентно; использует барьеры для корректности при
// релокации объектов.
// │ │ └── Подходит для latency-sensitive приложений; включается -XX:+UseZGC.
// │ └── Shenandoah — конкурентный compacting GC (RedHat / OpenJDK):
// │ ├── Выполняет concurrent compaction (сжатие/перемещение объектов в фоне), минимальные паузы,
// паузы не растут с размером heap.
// │ └── Отличный выбор для low-pause сценариев (альтернатива ZGC). ([docs.redhat.com][5])
// │
// │
// │
// |
// |
// |
// │
// | G1 Garbage Collector — Oracle/OpenJDK (G1 overview).
// | Z Garbage Collector (ZGC) — OpenJDK/Oracle docs.
// | Shenandoah GC — Red Hat / OpenJDK docs. ([docs.redhat.com][5])
// | Storage Management / TLAB — OpenJDK HotSpot docs. ([OpenJDK][1])
// | Практические статьи про allocation, card table и remembered sets. ([InfoQ][6])
//
//
//
//
// -Xms<size> и -Xmx<size>:
// Устанавливают начальный (-Xms) и максимальный (-Xmx) размер кучи.
// Например, -Xms512m -Xmx4g устанавливает начальный размер кучи в 512 мегабайт и максимальный в 4
// гигабайта.

// -XX:NewRatio=<ratio>:
// Определяет соотношение между старым и молодым поколением в куче.
// Например, -XX:NewRatio=2 означает, что старое поколение будет в два раза больше молодого.

// -XX:SurvivorRatio=<ratio>:
// Определяет соотношение между каждой из Survivor областей и Eden областью в молодом поколении.
// Например, -XX:SurvivorRatio=8 означает, что Eden будет в 8 раз больше каждой из Survivor
// областей.

// -XX:MaxTenuringThreshold=<value>:
// Устанавливает максимальное количество циклов сборки мусора, после которых объект из молодого
// поколения перемещается в старое.
// Более низкое значение означает более быстрое перемещение объектов в старое поколение.

// -XX:+Use<Collector>:
// Указывает, какой сборщик мусора использовать. Например, -XX:+UseG1GC, -XX:+UseParallelGC,
// -XX:+UseConcMarkSweepGC.



// Parallel GC:
// -XX:ParallelGCThreads=<n>: Устанавливает количество потоков для сборки мусора в Parallel GC.

// CMS (Concurrent Mark-Sweep):
// -XX:CMSInitiatingOccupancyFraction=<percent>: Указывает процент заполнения кучи, при котором
// начнется CMS cycle.
// -XX:+UseCMSInitiatingOccupancyOnly: Указывает JVM использовать только заданный процент для начала
// CMS cycle.

// G1 GC:
// -XX:MaxGCPauseMillis=<milliseconds>: Целевое значение для максимальной длительности паузы GC.
// -XX:G1HeapRegionSize=<size>: Устанавливает размер региона в G1 GC.

// ZGC:
// -XX:ConcGCThreads=<n>: Количество потоков, используемых для параллельной обработки в ZGC.

// Shenandoah:
// -XX:ShenandoahGCHeuristics=<heuristic>: Определяет эвристику, которую Shenandoah будет
// использовать.


// VisualVM
public class GCExample {
    // https://habr.com/ru/articles/269621/
    // https://shipilev.net/#shenandoah
    // https://habr.com/ru/companies/jugru/articles/846308/
    // https://habr.com/ru/companies/otus/articles/776342/
}
