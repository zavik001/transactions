package example.transactions.examples.java.core;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.sql.DriverManager;
import java.util.ArrayList;
import lombok.extern.slf4j.Slf4j;

// Полная карта: Class Loading → Bytecode → Execution → JIT → GC
// │
// |
// |
// |
// |
// |
// ├── 1. Формат класса и байткод (.class)
// │ ├── Структура .class файла (Class File Format)
// │ │ │
// │ │ ├── Magic number (0xCAFEBABE) — Это магическое число в начале каждого .class-файла, которое
// │ │ │ служит сигнатурой для идентификации файла как валидного Java-класса. Оно предотвращает
// │ │ │ случайную обработку неверных файлов и обеспечивает совместимость.
// │ │ │
// │ │ │
// │ │ ├── Minor/major version — Версии формата класса, где major указывает на основную версию JVM
// │ │ │ (например, 52 для Java 8), а minor — на подверсию. Это позволяет JVM проверять
// │ │ │ совместимость
// │ │ │ класса с текущей версией виртуальной машины и отклонять устаревшие или слишком новые файлы.
// │ │ │
// │ │ │
// │ │ ├── Constant Pool — Пул констант, который является таблицей ссылок на все константы,
// │ │ │ используемые в классе. Он оптимизирует хранение данных, избегая дублирования строк, чисел и
// │ │ │ ссылок, и служит основой для разрешения ссылок во время выполнения.
// │ │ │ |
// │ │ │ ├── CONSTANT_Utf8, Integer, Float, Long, Double — Базовые типы констант: Utf8 для строк
// │ │ │ | (включая имена классов и методов), а числовые для литералов. Они хранятся в пуле для
// │ │ │ | быстрого доступа и экономии места.
// │ │ │ |
// │ │ │ ├── Class, String, Fieldref, Methodref, InterfaceMethodref — Ссылки на классы, строки (как
// │ │ │ | CONSTANT_String), поля, методы и интерфейсные методы. Эти элементы используются для
// │ │ │ | описания структуры класса и его зависимостей.
// │ │ │ |
// │ │ │ ├── NameAndType, MethodHandle, MethodType, InvokeDynamic — NameAndType комбинирует имя и
// │ │ │ | тип; MethodHandle — для динамических вызовов; MethodType — дескриптор типа метода;
// │ │ │ | InvokeDynamic
// │ │ │ | — для поддержки динамических языков (например, lambda в Java 8+).
// │ │ │ |
// │ │ │ └── Bootstrap methods for invokedynamic — Таблица методов начальной загрузки для
// │ │ │ | invokedynamic, которая позволяет динамически связывать вызовы на этапе выполнения,
// │ │ │ | поддерживая такие фичи, как лямбды и метод-хэндлы (reference).
// │ │ │
// │ │ │
// │ │ ├── Access flags (public, final, etc.) — Флаги доступа, которые определяют видимость и
// │ │ │ свойства класса. Они кодируются в битовом поле и влияют на то, как класс может
// │ │ │ использоваться.
// │ │ │
// │ │ │
// │ │ ├── This class / super class indices — Индексы в пуле констант на текущий класс и суперкласс.
// │ │ │ Это позволяет быстро определять иерархию наследования без полного разбора строк.
// │ │ │
// │ │ │
// │ │ ├── Interfaces[] — Массив индексов интерфейсов, которые реализует класс. Каждый индекс
// │ │ │ ссылается на CONSTANT_Class в пуле, обеспечивая описание контрактов класса.
// │ │ │
// │ │ │
// │ │ ├── Fields[] (descriptor, attributes) — Массив полей класса: каждое включает имя, дескриптор
// │ │ │ (тип, например, "I" для int) и атрибуты (например, ConstantValue для статических констант).
// │ │ │ Это определяет структуру данных класса.
// │ │ │
// │ │ │
// │ │ ├── Methods[] (name, descriptor, Code attribute) — Массив методов: имя, дескриптор
// │ │ │ (сигнатура, например, "(II)V" для void метод с двумя int), и атрибуты, включая Code для
// │ │ │ байткода метода.
// │ │ │
// │ │ │
// │ │ └── Attributes[] (SourceFile, Signature, RuntimeVisibleAnnotations, InnerClasses, etc.) —
// │ │ │ Дополнительные атрибуты класса, такие как имя исходного файла, generics-сигнатуры,
// │ │ │ аннотации (видимые на runtime) и информация о внутренних классах. Они предоставляют
// │ │ │ метаданные для отладки и расширенных фич.
// │ │
// │ |
// │ ├── Bytecode instructions (Java Virtual Machine instruction set) — Набор инструкций JVM,
// │ | которые представляют собой машинный код для виртуальной машины. Они разделены на категории
// │ | для манипуляции данными, управления потоком и вызовами.
// │ │ |
// │ │ ├── load/store, arithmetic, conversion — Load/store загружают/сохраняют переменные;
// │ │ │ arithmetic (iadd, fmul) выполняют операции; conversion (i2f)
// │ │ │ преобразуют типы. Эти инструкции работают со стеком и локальными переменными.
// │ │ │
// │ │ │
// │ │ ├── control flow: goto, if_xxx, switch (tableswitch/lookupswitch) — Управление потоком: goto
// │ │ │ для безусловного прыжка, if_xxx для условных (например, ifeq), switch для множественного
// │ │ │ ветвления (tableswitch для плотных значений, lookupswitch для разреженных).
// │ │ │
// │ │ │
// │ │ ├── method invocation: invokevirtual, invokespecial, invokestatic, invokeinterface,
// │ │ │ invokedynamic — Вызовы методов: invokevirtual для виртуальных, invokespecial для
// │ │ │ приватных/конструкторов, invokestatic для статических, invokeinterface для интерфейсов,
// │ │ │ invokedynamic для динамических.
// │ │ │
// │ │ │
// │ │ ├── monitorenter/monitorexit (synchronized) — Инструкции для мониторинга объектов в
// │ │ │ synchronized-блоках, обеспечивающие thread-safety путем захвата/освобождения лока.
// │ │ │
// │ │ │
// │ │ └── return и throw — Return (ireturn, areturn и т.д.) возвращают значения из методов; athrow
// │ │ │ генерирует исключения. Они завершают выполнение метода.
// │ │ │
// │ │ │
// │ └── Атрибуты метода: Code (max_stack, max_locals, bytecode[], exception_table[], attributes) —
// │ │ │ Атрибут Code содержит стековую глубину (max_stack), количество локальных переменных
// │ │ │ (max_locals), массив байткода, таблицу исключений (для try-catch) и вложенные атрибуты
// │ │ │ (например, LineNumberTable для отладки).
// │
// │
// |
// |
// |
// |
// |
// |
// ├── 2. Class loading (загрузка классов)
// │ ├── Роль ClassLoader'ов — ClassLoader'ы отвечают за поиск и загрузку классов из различных
// │ │ источников (файлы, сеть, JAR), преобразование байтов в объекты Class и управление
// │ │ namespace'ами для изоляции.
// │ │ |
// │ │ ├── Преобразуют бинарные данные (byte[]) в java.lang.Class объектов — Метод defineClass()
// │ │ | парсит байты и создает Class-объект, который представляет класс в JVM.
// │ │ |
// │ │ ├── Управляют изоляцией пространств классов (плагины, app servers) — Разные ClassLoader'ы
// │ │ | могут загружать одинаковые классы в разные пространства, предотвращая конфликты в
// │ │ | многомодульных системах.
// │ │
// │ │
// │ ├── Иерархия загрузчиков (в HotSpot) — Стандартная иерархия обеспечивает приоритет загрузки
// │ │ core-классов и безопасность.
// │ │ |
// │ │ ├── Bootstrap ClassLoader (native) — JDK core (rt.jar / модули) — Нативный загрузчик,
// │ │ | загружающий базовые классы Java (java.lang.*, Object, String) из системных ресурсов.
// │ │ |
// │ │ ├── Platform (Extension) ClassLoader — JDK расширения / платформенные — Загружает расширения
// │ │ | JDK, из платформенных директорий. (публичные типы системных модулей, которые могут
// │ │ | понадобиться)
// │ │ |
// │ │ └── Application (System) ClassLoader — classpath приложения — Загружает классы из CLASSPATH,
// │ │ | включая пользовательские классы приложения.
// │ │ |
// │ ├── Parent delegation model (делегирование родителю) — Модель, где загрузчик сначала делегирует
// │ │ | запрос родительскому, чтобы избежать дубликатов и обеспечить единообразие.
// │ │ |
// │ │ |
// │ │ ├── loadClass() делегирует родителю прежде чем искать сам — Алгоритм: проверить кэш,
// │ │ | делегировать parent'у, если не найден — найти сам.
// │ │ └── Цель: избежать дублирования core-классов и сохранить безопасность — Это предотвращает
// │ │ | подмену системных классов вредоносным кодом.
// │ │ |
// │ │ |
// │ ├── Custom ClassLoader — Пользовательские загрузчики для специфических нужд.
// │ │ ├── findClass(), defineClass(), resolveClass() — findClass() ищет байты, defineClass()
// │ │ | создает Class, resolveClass() разрешает ссылки.
// │ │ ├── Использование: плагинные системы, OSGi, hot-reload, sandboxing — Например, в OSGi каждый
// │ │ | бандл имеет свой ClassLoader для модульности.
// │ │ └── Возможные ловушки: memory leaks при удержании ClassLoader → классы/метаданные — Если
// │ │ | ClassLoader не освобождается, метаданные классов остаются в Metaspace, вызывая утечки.
// │ │
// │ │
// │ ├── Загрузка ресурса — Методы для поиска не-класcных ресурсов, таких как свойства или
// │ │ изображения.
// │ │ ├── getResource(), getResourceAsStream() — getResource() возвращает URL,
// │ │ | getResourceAsStream() — поток для чтения.
// │ │ |
// │ │ └── Различия между ClassLoader и Class.getResource — Class.getResource использует ClassLoader
// │ │ | класса, ClassLoader — свой собственный; Class.getResource поддерживает относительные пути.
// │ └── Безопасность — Механизмы для предотвращения вредоносного кода.
// │ ├── Проверка подписей JAR — JVM проверяет цифровые подписи JAR-файлов для аутентичности.
// │ ├── SecurityManager / AccessController (частично устаревшие) — Управляют разрешениями, но в
// │ │ Java 17+ частично удалены в пользу модулей.
// │
// │
// │
// |
// |
// |
// |
// |
// |
// ├── 3. Linking — проверка, подготовка, разрешение
// | |
// │ ├── Verification (проверка байткода) — Этап, где JVM убеждается, что байткод безопасен и
// | | корректен.
// │ │ ├── Цель: гарантировать корректность типов, границ стеков, отсутствие «опасного» кода —
// | | Проверяет типы операндов, стековую дисциплину и отсутствие переполнений.
// │ │ ├── Этап проверки: structural, semantic checks — Structural: формат файла; semantic: типовая
// | | безопасность, контроль доступа.
// │ ├── Preparation (подготовка) — Подготовка памяти для класса.
// │ │ ├── Выделение и инициализация статических полей значениями по-умолчанию — Статические поля
// | | устанавливаются в 0/null/false перед инициализацией.
// │ ├── Resolution (разрешение) — Замена символов на реальные адреса.
// │ │ ├── Замена символических ссылок (constant pool refs) на прямые (runtime) ссылки — Преобразует
// │ │ индексы в пуле в реальные ссылки на классы/методы.
// │ │ ├── Lazy vs eager resolution (HotSpot делает ленивую резолюцию для методов/fields) — Lazy:
// │ │ разрешает только при первом использовании для ускорения загрузки.
// │
// │
// │
// |
// |
// |
// |
// |
// |
// ├── 4. Initialization (инициализация класса)
// │ ├── Выполнение static-инициализаторов и assignment'ов в определённом порядке — Статические поля
// | и блоки инициализируются сверху вниз, после суперкласса.
// │ ├── Class.forName(..., true, classloader) вызывает инициализацию — Метод forName с флагом true
// | запускает инициализацию; без — только загрузку.
// │ └── Безопасная публикация и видимость static-полей (happens-before rules) — JMM гарантирует
// | видимость статических полей после инициализации через happens-before.
// │
// │
// │
// |
// |
// |
// |
// |
// |
// ├── 5. Создание экземпляров и память (GC)
// |
// |
// |
// |
// |
// │
// ├── 6. JVM Execution Engine (исполнение)
// │ |
// │ ├── Интерпретатор (bytecode interpreter) — Прямое выполнение байткода построчно.
// │ │ ├── Быстрый путь для старта — выполняет байткод напрямую — Не требует компиляции, идеален для
// │ | редкого кода.
// │ │ └── Подсчёт профилей исполнения (частота вызовов, горячие методы) — Счетчики вызовов и
// │ | backedges для выявления кандидатов на JIT.
// │ ├── JIT компилятор (Just-In-Time) — Динамическая компиляция в нативный код.
// │ │ ├── Цель: компилировать горячие участки в машинный код для скорости — Увеличивает
// │ │ производительность в 10-100 раз для часто выполняемого кода.
// │ │ ├── Tiered compilation (несколько уровней) — Многоуровневая компиляция для баланса скорости и
// │ │ качества.
// │ │ │ ├── C1 (client compiler) — быстрый, менее агрессивный (обычно уровень 1–2) — Простые
// │ │ оптимизации, быстро компилирует.
// │ │ │ └── C2 (server compiler) — более медленный, агрессивные оптимизации (уровень 3+) — Глубокие
// │ | оптимизации на основе профилей.
// │ │ ├── Tiered: интерпретатор → C1 (baseline) → C2 (optimizing) — Последовательный апгрейд: от
// │ | интерпретации к базовой, затем к оптимизированной компиляции.
// │ │ ├── Профилирование (онлайн-профайл) — сбор профилей вызовов, типов аргументов — Собирает
// │ | данные о типах, ветвлениях для targeted оптимизаций.
// │ │ ├── Инлайнинг методов (method inlining) — ключ к оптимизациям — Заменяет вызовы на тело
// │ | метода, уменьшая overhead и открывая дальнейшие оптимизации.
// │ │ ├── Escape Analysis — Анализ, определяющий область видимости объектов.
// │ │ │ ├── Определяет, не «убегает» ли объект за пределы метода/потока — Если объект локален,
// │ | можно оптимизировать.
// │ │ │ ├── Стековая аллокация (scalar replacement) / удаление аллокации — Заменяет объект
// │ | скалярами на стеке, избегая heap-аллокации.
// │ │ ├── Intrinsics — заменяет Java-методы нативными высокопроизводительными реализациями
// │ | (например, System.arraycopy) — JVM подменяет стандартные методы на оптимизированные
// │ | ассемблерные версии.
// │ │ ├── Deoptimization (деоптимизация) — Откат к интерпретации.
// │ │ │ ├── Возврат из скомпилированного кода в интерпретируемый при нарушении предположений — Если
// │ │ │ профиль изменился (например, новый subclass), код деоптимизируется.
// │ │ │ ├── Нужно для безопасной корректности при изменении классов/развертывании — Поддерживает
// │ │ │ динамизм Java.
// │ │ ├── On-Stack Replacement (OSR) — Замена кода на лету.
// │ │ │ ├── Замена исполняющегося цикла/метода на скомпилированную версию «на лету» — Для
// │ │ │ долгоживущих циклов: компиляция и замена без прерывания.
// │ │ └── Inline caches / polymorphic inline cache — ускорение вызовов виртуальных методов — Кэш
// │ │ │ для мономорфных/полиморфных вызовов: прямой вызов для одного типа, таблица для нескольких.
// │ ├── Native methods / JNI — Интерфейс для нативного кода.
// │ │ ├── Вызовы в native код (C/C++) — JNI позволяет вызывать C-функции из Java для
// │ │ │ производительности или интеграции.
// │ │ └── Управление корректностью и безопасностью — Требует осторожности: пиннинг объектов,
// │ │ │ обработка исключений.
// │ └── Safepoints (сейфпоинты) — Точки, где потоки могут быть остановлены.
// │ ├── Точки остановки всех потоков для GC или других глобальных операций — Вставляются в код для
// │ │ │ синхронизации (например, в циклах, вызовах).
// │ ├── Опасность: остановка потоков влияет на latency — Долгие safepoints вызывают паузы в
// │ │ │приложении.
// │
// |
// |
// |
// |
// |
// │
// ├── 7. HotSpot оптимизации и поведение
// │ ├── Tiered compilation flags (-XX:+TieredCompilation, -XX:CICompilerCount) — Включает уровни
// │ │ компиляции и задает количество компиляторных потоков.
// │ ├── Compilation thresholds (hotmethod, backedge counters) — Пороги: счетчики вызовов (например,
// │ │ 10000) и backedges (для циклов) для триггера компиляции.
// │ ├── Biased locking, lock elision, lock coarsening — Оптимизации синхронизации: biased — лок для
// │ │ одного потока; elision — удаление ненужных локом; coarsening — объединение локом.
// │ ├── Escape analysis для удаления синхронизации и аллокаций — Если объект не убегает, удаляет
// │ │ synchronized и аллокации.
// │ ├── Profile-guided optimizations (runtime profile feedback) — Оптимизации на основе собранных
// │ │ профилей, такие как branch prediction.
// │ └── Deoptimization и class redefinition (HotSwap, JVMTI) — Deopt для отката; HotSwap для замены
// │ │ методов в runtime.
// │
// |
// |
// |
// |
// │
// ├── 8. Class unloading и Metaspace
// │ ├── Metaspace (заменил PermGen) — хранит метаданные классов (native memory) — Автоматически
// │ │ растет, но может быть ограничено, чтобы избежать OOM.
// │ ├── Условия выгрузки класса:
// │ │ ├── Нет живых экземпляров классов — Все объекты класса должны быть собраны GC.
// │ │ ├── Нет сильных ссылок на ClassLoader (ClassLoader unreachable) — ClassLoader должен стать
// │ │ unreachable для GC.
// │ │ └── GC может выполнить выгрузку и освободить Metaspace — Выгрузка происходит во время Full
// │ │ GC.
// │ ├── Утечки: удержание ссылок на ClassLoader (static collections, thread locals) — Static поля
// │ │ или ThreadLocal могут удерживать ClassLoader, предотвращая выгрузку.
// │ └── Флаги управления: -XX:MaxMetaspaceSize, -XX:MetaspaceSize — Max — лимит, MetaspaceSize —
// │ │ начальный размер для триггера GC.
// │
// │
// |
// |
// |
// |
// │
// ├── 9. Garbage Collection
// │
// │
// |
// |
// |
// |
// │
// ├── 15. Runtime class redefinition / HotSwap / JVMTI
// │ ├── HotSwap (ограниченное переопределение методов во время отладки) — В IDE: меняет тело
// │ │ методов, но не структуру.
// │ ├── Instrumentation API (java.lang.instrument) — агент, redefineClasses() — Агенты для
// │ │ bytecode-манипуляции в runtime.
// │ └── JVMTI — агенты нативного уровня для трассировки и профайлинга — Низкоуровневый интерфейс
// │ │ для инструментов вроде debuggers.
// │
// ├── 16. Типичные проблемы и anti-patterns
// │ ├── ClassLoader leaks (retened references) — Утечки от удержания ClassLoader в static или
// │ │ thread-local.
// │ ├── PermGen/Metaspace OOM при динамической загрузке классов — Слишком много классов без
// │ │ выгрузки.
// │ ├── Long GC pauses из-за большого Old gen / fragmentation — Большой heap приводит к долгим Full
// │ │ GC.
// │ ├── Частые Full GC из-за неправильной настройки heap — Малый young/old ratio вызывает
// │ │ promotion.
// │ ├── Deoptimization spikes при частом изменении классов или Profile instability — Частые deopt
// │ │ от полиморфизма или hotswap.
// │ └── Unsafe usage / native mem leaks (DirectByteBuffer leaks) — Неочищенные DirectBuffer или JNI
// │ │ приводят к native OOM.
// │
// │
// |
// |
// |
// |
// |
// │
// 1. Компиляция .java → .class (байткод, constant pool) — Javac создает .class с байткодом и
// метаданными.
// 2. ClassLoader загружает байты в JVM (defineClass) — Находит байты, парсит в Class.
// 3. Linking: verification → preparation → (lazy) resolution — Проверка, подготовка, разрешение
// ссылок.
// 4. Initialization: static блоки, статические поля — Выполнение инициализаторов.
// 5. Allocation: объекты выделяются в Heap (TLAB, Eden) — New создает экземпляры в young gen.
// 6. Execution starts: интерпретатор выполняет байткод — Прямое исполнение.
// 7. JIT компиляторы (C1/C2) собирают профили и компилируют горячие участки — Tiered компиляция для
// скорости.
// 8. Optimizations: inlining, escape analysis, intrinsics, OSR — Улучшения на основе профилей.
// 9. При необходимости — safepoints, деоптимизация, class redefinition — Остановки, откаты,
// изменения.
// 10. GC: через mark/sweep/compact или copy/evacuate (в зависимости от алгоритма) — Освобождает
// память и может выгрузить ненужные ClassLoader/Metaspace, завершая цикл.

// https://habr.com/ru/articles/748758/
@Slf4j
public class ClassLoaderExample extends ClassLoader {
    public static void printClassLoaders() throws ClassNotFoundException {

        log.info("Platform Classloader:" + ClassLoader.getPlatformClassLoader());

        log.info("System Classloader:" + ClassLoader.getSystemClassLoader());

        log.info("Classloader of this class:" + ClassLoaderExample.class.getClassLoader());

        log.info("Classloader of DriverManager:" + DriverManager.class.getClassLoader());

        log.info("Classloader of ArrayList:" + ArrayList.class.getClassLoader());
    }

    @Override
    public Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] b = loadClassFromFile(name);
        return defineClass(name, b, 0, b.length);
    }

    private byte[] loadClassFromFile(String name) {
        InputStream inputStream = getClass().getClassLoader().getResourceAsStream(name);

        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
        int nextValue;
        try {
            while ((nextValue = inputStream.read()) != 1) {
                byteStream.write(nextValue);
            }
        } catch (IOException e) {
        }

        return byteStream.toByteArray();
    }
}
