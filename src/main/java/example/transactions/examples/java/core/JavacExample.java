package example.transactions.examples.java.core;

// Javac — полный, подробный разбор
// │
// │
// ├── Что это такое:
// │ ├── javac — компилятор Java (Java Compiler), часть JDK, который преобразует исходный код
// | (.java)│ в байт-код (.class).
// │ ├── Это front-end часть toolchain: анализирует синтаксис, семантику и генерирует промежуточное
// │ представление (байткод), исполняемое JVM.
// │ ├── Байткод платформенно-независим: он не привязан к архитектуре CPU/OS, что и обеспечивает
// │ кроссплатформенность на уровне JVM.
// │ └── Компиляция происходит до выполнения, но может сочетаться с JIT-компиляцией во время работы.
// │
// │
// ├── Основные этапы работы javac:
// │ ├── 1. Парсинг (Parsing):
// │ │ ├── Лексический анализ (tokenizer/lexer) — разбивает исходный код на токены.
// │ │ └── Синтаксический анализ (parser) — строит AST (Abstract Syntax Tree).
// │ ├── 2. Анализ (Semantic analysis):
// │ │ ├── Проверка типов (type checking) — статический анализ совместимости типов.
// │ │ ├── Проверка видимости (access control) — private/protected/public.
// │ │ └── Анализ аннотаций и обработка Annotation Processors (APT).
// │ ├── 3. Генерация байткода (Bytecode generation):
// │ │ ├── Построение Constant Pool (таблица литералов, имен, ссылок на методы и классы).
// │ │ ├── Преобразование AST в инструкции JVM (опкоды).
// │ │ └── Оптимизации на уровне компилятора (peephole optimization).
// │ ├── 4. Запись .class-файлов:
// │ │ └── Каждый скомпилированный класс/интерфейс → отдельный .class файл.
// │
// │
// ├── Стирание дженериков (Type Erasure):
// │ ├── В Java generics — compile-time конструкция: они нужны только для проверки типов во время
// │ компиляции.
// │ ├── После компиляции дженерики стираются — в байткоде остаются "raw types".
// │ ├── Например: List<String> и List<Integer> после компиляции выглядят одинаково (List).
// │ ├── Вставляются необходимые приведения типов (cast) в байткод для безопасности.
// │ └── Последствия:
// │ ├── Нет перегрузки методов по параметрам с разными generic-типами.
// │ ├── Нельзя делать new T() или T.class.
// │ └── Reflection не видит параметры generic'ов (их нет в runtime).
// │
// │
// ├── Связь с ClassLoader и Reflection:
// │ ├── ClassLoader:
// │ │ ├── После того как javac сгенерировал .class файлы — загрузка их в память выполняется
// │ │ ClassLoader'ами JVM.
// │ │ ├── Разные ClassLoader'ы позволяют подгружать разные версии одного класса, изолировать
// плагины,
// │ │ реализовывать hot-reload (напр. в серверах приложений).
// │ │ └── Кроссплатформенность: один и тот же байткод можно загрузить на любой платформе с JVM.
// │ ├── Reflection:
// │ │ ├── Позволяет во время выполнения анализировать структуру классов (поля, методы, аннотации)
// │ │ и вызывать их динамически.
// │ │ ├── Reflection часто работает через ClassLoader — сначала загрузить класс, потом получить
// │ │ его метаданные через Class<?>.
// │ │ └── Это ключ к созданию фреймворков (Spring, Hibernate), которые строят поведение программы
// │ │ на основе информации, полученной в runtime.
// │
// │
// ├── Полезные флаги javac:
// │ ├── -d <директория> — куда сохранять .class файлы.
// │ ├── -classpath (или -cp) — указывает пути поиска зависимостей.
// │ ├── -source <версия> и -target <версия> — совместимость исходников и байткода.
// │ ├── --release <версия> — единый флаг для source+target+bootclasspath.
// │ ├── -parameters — сохраняет имена параметров методов в байткод (полезно для Reflection).
// │ └── -Xlint — вывод предупреждений компилятора (unchecked, deprecation и т.д.).
public class JavacExample {

}
